# srun -p small -n 2 --qos=small --pty /bin/bash #交互式生成节点
# cd /dssg/home/acct-mashiyang1991/mashiyang1991/shiyang #工作文件夹
# module load miniconda3/4.10.3  #加载conda环境
# source activate R
# R

#conda -n -p biocondutor

#rm(list=ls()) 

#Enable command line arguments
args = commandArgs(TRUE)
args=1#上超算要注释掉
variant_type = c('common','rvariant_typeare')[as.numeric(args[1])]
out_type = c('TTE')
print(paste0('variant_type: ', variant_type, ' out_type: ', out_type))

# 定义包列表
packages <- c("SKAT", "Matrix", "knockoff", "WGScan", "numDeriv", "glmnet", "SPAtest", "CompQuadForm")

# 检查并安装缺失的包
new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if (length(new_packages)) install.packages(new_packages)
#Load SKAT haplotypes
library(SKAT)
library(Matrix)
library(knockoff)
library(WGScan)
library(numDeriv)
library(glmnet)
library(SPAtest)
library(CompQuadForm)
library(irlba)
library(survival)

#library(devtools)  # author version: 2.1.0
#install_github("WenjianBi/SPACox")
#devtools::install_github("WenjianBi/SPACox")
#library(SPACox)

library(rjson)
library(ranger)
library(doParallel)
library(bigmemory)
library(data.table)
source("KnockoffScreen.r")
source("SPACox.R")

data(SKAT.haplotypes)
data<-SKAT.haplotypes$Haplotype;info<-SKAT.haplotypes$SNPInfo

# a numeric matrix of 10,000 haplotypes over 200k BP region. Each row represents a
# different haplotype, and each column represents a different SNP marker. It is generated by the
# calibration coalescent model (COSI) with mimicking LD structure of European ancestry.
#hist(info[,5],main="Histogram of MAF over 200kb region",xlab='MAF')

m<-10000
n.G<-3845
M<-5
nrep=5
id=1:10000

result.all<-c();result.detail<-c()
result.BH.all<-c();result.BH.detail<-c()
if(variant_type=='common'){h2<-0.05}else{h2<-0.25}

for (P.causal in c(0.015)) {
  for (i in 1:nrep) {
    set.seed(12345 + i)
    
    # --- 生成基因型和Knockoff的逻辑（保持不变） ---
    if (i %in% seq(1, 500, by = 25)) {
      #Generate SNP sets
      SNP.index<-1:3845  #sort(sample(1:ncol(data),n.G))
      sample.index<-sample(1:nrow(data),m*2,replace=T)
      SNP.set<-data[sample.index[1:m],SNP.index]+data[sample.index[(m+1):(2*m)],SNP.index] #generate genotype from haplotype
      range(SNP.set) #0 2 this is a genotype data
      pos<-info[SNP.index,3]
      MAF<-apply(SNP.set,2,mean)/2
      
      SNP.set[,MAF>0.5]<-2-SNP.set[,MAF>0.5]
      MAF<-apply(SNP.set,2,mean)/2
      MAC<-apply(SNP.set,2,sum)
      
      if(variant_type=='common'){rare.index<-MAF>=0.01 & MAF>0}else{
        rare.index<-MAF<0.01 & MAF>0
      }
      
      SNP.set<-SNP.set[,rare.index];MAF<-MAF[rare.index];MAC<-MAC[rare.index];pos<-pos[rare.index]
      N.SNP<-ncol(SNP.set)
      N.SNP #579 common variants; 3100 rare variants
      
      cor.X<-sparse.cor(Matrix(SNP.set))$cor
      Sigma.distance = as.dist(1 - abs(cor.X))
      fit = hclust(Sigma.distance, method="single")
      corr_max = 0.75
      clusters = cutree(fit, h=1-corr_max)
      cluster.index<-match(unique(clusters),clusters)
      SNP.set<-SNP.set[,cluster.index];MAF<-MAF[cluster.index];MAC<-MAC[cluster.index];pos<-pos[cluster.index]
      N.SNP<-ncol(SNP.set)
      
      G<-SNP.set
      dim(G) #10000   140; 2181 after LD.filter
      MAF<-apply(G,2,mean)/2
      MAC<-apply(G,2,sum)
      N.SNP<-ncol(G)
      
      MAF.threshold<-0.01;Z<-as.matrix(rep(1,ncol(G)));
      
      #focus on single variant score test
      G<-Matrix(G,sparse=T)
      G<-as.matrix(G)
      
      signal.region<-10000
      print('generating knockoffs')
      proc.time()
      G_k<-create.MK(G,pos,M=5,maxN.neighbor=Inf,maxBP.neighbor=0.1*10^6)
    }
    #generate causal
    repeat {
      start <- sample(pos, 1)#生成基因窗口
      end <- start + signal.region
      signal.index <- which(pos >= start & pos <= end)
      n_causal <- ceiling(N.SNP * P.causal)
      if (n_causal <= length(signal.index)) {
        break
      }
    }
    causal.index <- (1:N.SNP) %in% sample(signal.index, n_causal)
    # start<-sample(pos,1);end<-start+signal.region
    # signal.index<-which(pos>=start & pos<=end)
    # print(sum(signal.index))
    # print(N.SNP)
    # # causal.index<-(1:N.SNP)%in%sample(signal.index,ceiling(length(signal.index)*P.causal))
    # causal.index<-(1:N.SNP)%in%sample(signal.index,ceiling(N.SNP*P.causal))
    beta<-as.matrix(sqrt(h2/sum(causal.index)/apply(G,2,var))*causal.index)
    
    # --- 生成表型和分析 ---
    if (out_type == 'TTE') {
      X1<-rnorm(m,0,1)
      eta<-X1+G%*%beta
      U <- runif(m, 0, 1)
      lambda <- 0.001
      lambda_c <- 0.001
      
      T_f <- -log(U)/(lambda*exp(eta)) #failure time
      T_c <- rexp(m, rate = lambda_c) #censoring time
      
      delta <- as.integer(T_f <= T_c) #failure is observed
      TTE=apply(cbind(T_f, T_c),1,min)
      
      event_rate <- mean(delta)
      censoring_rate <- 1 - event_rate
      
      print(paste0('event rate: ', event_rate, ' censoring rate: ', censoring_rate))
      #event rate: 0.514 censoring rate: 0.486
    }
    
    #Use SPACox package to fit a null Cox proportional hazards modeland then calculate p value for each genetic variant.
    obj.null = SPACox_Null_Model(Surv(TTE,delta)~X1,pIDs=id, gIDs=id)
    row.names(G)=id
    colnames(G)=pos
    SPACox.result = SPACox(obj.null, G)
    dim(SPACox.result) #single variant score test results for original genotype
    
    #For knockoffs
    G_knockoff1=as.matrix(G_k[[1]])
    row.names(G_knockoff1)=id;colnames(G_knockoff1)=pos
    SPACox.result_knockoff1 = SPACox(obj.null, G_knockoff1)
    
    G_knockoff2=as.matrix(G_k[[2]])
    row.names(G_knockoff2)=id;colnames(G_knockoff2)=pos
    SPACox.result_knockoff2 = SPACox(obj.null, G_knockoff2)
    
    G_knockoff3=as.matrix(G_k[[3]])
    row.names(G_knockoff3)=id;colnames(G_knockoff3)=pos
    SPACox.result_knockoff3 = SPACox(obj.null, G_knockoff3)
    
    G_knockoff4=as.matrix(G_k[[4]])
    row.names(G_knockoff4)=id;colnames(G_knockoff4)=pos
    SPACox.result_knockoff4 = SPACox(obj.null, G_knockoff4)
    
    G_knockoff5=as.matrix(G_k[[5]])
    row.names(G_knockoff5)=id;colnames(G_knockoff5)=pos
    SPACox.result_knockoff5 = SPACox(obj.null, G_knockoff5)
    
    
    #SPACox-BH
    p.A=SPACox.result[,3]
    p.SPACox_BH=p.adjust(p.A,method = 'BH')
    p.SPACox_BH
    
    result.BH<-c()
    for(fdr in seq(0,0.2,by=0.01)){
      selected.BH<-which(p.SPACox_BH<=fdr);selected.BH[is.na(selected.BH)]<-F
      signal<-which(causal.index)
      power<-function(x){sum(signal%in%x)/length(signal)}
      fdr<-function(x){sum(!x%in%signal)/length(x)}
      result.BH<-rbind(result.BH,c(power(selected.BH),fdr(selected.BH)))
    }
    result.BH.detail<-rbind(result.BH.detail,cbind(i,h2,P.causal,seq(0,0.2,by=0.01),result.BH))
    
     #Cox-Knockoff
      p.A=SPACox.result[,3]
      p.A_k=cbind(SPACox.result_knockoff1[,3],
                  SPACox.result_knockoff2[,3],
                  SPACox.result_knockoff3[,3],
                  SPACox.result_knockoff4[,3],
                  SPACox.result_knockoff5[,3])
      W<-(-log10(p.A)-apply(-log10(p.A_k),1,median))*(-log10(p.A)>=apply(-log10(p.A_k),1,max))
      MK.stat<-MK.statistic(-log10(p.A),-log10(p.A_k),method='median')

      stat <- MK.stat
      colnames(stat) <- c('kappa','tau')
      q<-MK.q.byStat(stat[,'kappa'],stat[,'tau'],M=5)
      print(min(q))

      stat <-cbind(stat,q)
      colnames(stat)[3] <- 'Qvalue'

    # Cox-Knockoff 结果统计
      result<-c()
        for(fdr in seq(0,0.2,by=0.01)){
          selected<-which(stat[,"Qvalue"]<=fdr);selected[is.na(selected)]<-F
          signal<-which(causal.index)    #which(c(t(beta!=0)%*%window.matrix0!=0,(beta!=0)[MAF>0.01]))
          power<-function(x){sum(signal%in%x)/length(signal)}
          fdr<-function(x){sum(!x%in%signal)/length(x)}
          # result<-rbind(result,c(apply(selected,2,power),apply(selected,2,fdr)))
          result<-rbind(result,c(power(selected),fdr(selected)))
        }
        result.detail<-rbind(result.detail,cbind(i,h2,P.causal,seq(0,0.2,by=0.01),result))
  }  # 结束内层循环 (i in 1:nrep)
  
  # --- 汇总结果并保存 ---
  # SPACox-BH 结果汇总
  colnames(result.BH.detail)<-c('replicate','h2','P.causal','fdr_target','power','fdr')
  result.BH.detail[,6][is.na(result.BH.detail[,6])]=0
  write.table(result.BH.detail,paste0('E:/AT/knockoff相关资料/Cox konckoff/Cox_Knockoff/result.BH_',variant_type,'_',out_type,'_detail.txt'),row.names=F,col.names=T,quote=F,sep='\t')
  result.BH.all <- cbind(h2, P.causal, seq(0, 0.2, by = 0.01), rep(0, 21), rep(0, 21))
  colnames(result.BH.all) <- c('h2', 'P.causal', 'fdr_target', 'power', 'fdr')
  for (fdr in seq(0, 0.2, by = 0.01)) {
    result.BH.all[result.BH.all[, 3] == fdr, 4] <- mean(result.BH.detail[result.BH.detail[, 4] == fdr, 5], na.rm = TRUE)
    result.BH.all[result.BH.all[, 3] == fdr, 5] <- mean(result.BH.detail[result.BH.detail[, 4] == fdr, 6], na.rm = TRUE)
  }
  result.BH.all<-round(result.BH.all,digits=3)
  write.table(result.BH.all,paste0('E:/AT/knockoff相关资料/Cox konckoff/Cox_Knockoff/result.BH_',variant_type,'_',out_type,'.txt'),row.names=T,col.names=F,quote=F,sep='\t')
  
  # Cox-Knockoff 结果汇总
  colnames(result.detail)<-c('replicate','h2','P.causal','fdr_target','power','fdr')
  result.detail[,6][is.na(result.detail[,6])]=0
  write.table(result.detail,paste0('E:/AT/knockoff相关资料/Cox konckoff/Cox_Knockoff/result_knockoff_',variant_type,'_',out_type,'_detail.txt'),row.names=F,col.names=T,quote=F,sep='\t')
  result.all<-cbind(h2,P.causal,seq(0,0.2,by=0.01),rep(0,21),rep(0,21))
  colnames(result.all)<-c('h2','P.causal','fdr_target','power','fdr')
  for(fdr in seq(0,0.2,by=0.01)){
    result.all[result.all[,3]==fdr,4]=mean(result.detail[result.detail[,4]==fdr,5])
    result.all[result.all[,3]==fdr,5]=mean(result.detail[result.detail[,4]==fdr,6],na.rm=TRUE)
  }
  result.all<-round(result.all,digits=3)
  write.table(result.all,paste0('E:/AT/knockoff相关资料/Cox konckoff/Cox_Knockoff/result_knockoff_',variant_type,'_',out_type,'.txt'),row.names=T,col.names=F,quote=F,sep='\t')
}  # 结束外层循环 (P.causal in c(0.015))

##################################
# cd /dssg/home/acct-mashiyang1991/mashiyang1991/shiyang

# while read -r first; do
# 
#   sbatch loop.slurm $first
# 
# done < args.txt